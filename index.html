<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MS TETRIS</title>
    <link rel="stylesheet" href="./style.css?2510271741">
</head>
<body>
    <script>
        const MS_TETRIS = function() {
            this.grid = {
                horizontal: 11,
                vertical: 19
            }
			this.gameOption = {
				scorePerBlock: 10,
				scorePerLine: 100,
				speedPerStage: 50,
			}
            this.protoTypes = {
                    1: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [0, 1, 1, 0],
                                [0, 1, 1, 0],
                                [0, 0, 0, 0],
                            ]
                        ],
                        color: "red"
                    },
                    2: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [1, 1, 1, 1],
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 1, 0]
                            ]
                        ],
                        color: "green"
                    },
                    3: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [0, 0, 1, 1],
                                [0, 1, 1, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 0, 1, 1],
                                [0, 0, 0, 1],
                                [0, 0, 0, 0],
                            ]
                        ],
                        color: "blue"
                    },
                    4: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [0, 1, 1, 0],
                                [0, 0, 1, 1],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 0, 1],
                                [0, 0, 1, 1],
                                [0, 0, 1, 0],
                                [0, 0, 0, 0],
                            ]
                        ],
                        color: "yellow"
                    },
                    5: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [0, 1, 1, 1],
                                [0, 1, 0, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 1, 1],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 0, 1],
                                [0, 1, 1, 1],
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 1, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 0, 0],
                            ]
                        ],
                        color: "orange"
                    },
                    6: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [0, 1, 1, 1],
                                [0, 0, 0, 1],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 1],
                                [0, 0, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 1, 0, 0],
                                [0, 1, 1, 1],
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 0, 1, 0],
                                [0, 1, 1, 0],
                                [0, 0, 0, 0],
                            ]
                        ],
                        color: "purple"
                    },
                    7: {
                        types: [
                            [
                                [0, 0, 0, 0],
                                [0, 1, 1, 1],
                                [0, 0, 1, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 0, 1, 1],
                                [0, 0, 1, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 1, 1, 1],
                                [0, 0, 0, 0],
                                [0, 0, 0, 0],
                            ],
                            [
                                [0, 0, 1, 0],
                                [0, 1, 1, 0],
                                [0, 0, 1, 0],
                                [0, 0, 0, 0],
                            ]
                        ],
                        color: "skyblue"
                    }
                }
            this.cellSize = 50;
            this.Block = function(protoType, position) {//Class
                this.protoType = protoType;
                this.currentType = 0;
                this.position = position;
            }
			this.Game = function(root, option) {
				this.rootLayer = root;//Class
				this.option = option;
				this.stage = 1;
				this.score = 0;
				this.speed = 1000;
				this.clearedBlocks = 0;
				this.clearedLines = 0;
                this.started = false;
                this.paused = false;
				this.clearBlock = () => {
					this.clearedBlocks ++;
					this.score += this.option.scorePerBlock * this.stage;
					this.updateInfo();
				}
				this.clearLine = (clearedLines) => {
					this.clearedLines += clearedLines;
					if (!(this.clearedLines % 5)) this.upStage();
					this.score += this.option.scorePerLine * this.stage * clearedLines;
					this.updateInfo();
				}
				this.upStage = () => {
					this.stage ++;
					this.setSpeed();
					this.updateInfo();
				}
				this.setSpeed = () => {
					this.speed = 1000 - this.stage * this.option.speedPerStage;
				}
				this.setGameInfo = () => {
					this.gameInfo = document.createElement("div");
					this.gameInfo.id = "gameInfo";
					this.gameInfo.innerHTML =
					`
						<div class="gameInfo stage">
							<em>STAGE: </em>
							<span class="value">${this.stage}</span>
						</div>
						<div class="gameInfo score">
							<em>SCORE: </em>
							<span class="value">${this.score}</span>
						</div>
					`;
                    this.pauseButton = document.createElement("button");
                    this.pauseButton.id = "pause";
                    this.pauseButton.textContent = "PAUSE";
                    this.gameInfo.appendChild(this.pauseButton);
					this.rootLayer.appendChild(this.gameInfo);
				}
				this.updateInfo = () => {
					this.gameInfo.querySelector(".stage .value").textContent = this.stage;
					this.gameInfo.querySelector(".score .value").textContent = this.score;
				}
				this.init = () => {
                    this.started = true;
					this.setSpeed();
					this.setGameInfo();
				}
				this.init();
			}
			this.createBlock = () => {
                const pickedCurrentType = this.pickType();
                this.currentBlock = typeof this.nextBlock === 'undefined' ? new this.Block(pickedCurrentType.protoType, pickedCurrentType.position) : this.nextBlock;
                const pickedNextType = this.pickType();
                this.nextBlock = new this.Block(pickedNextType.protoType, pickedNextType.position);
                this.setNextBlockPreview(this.nextBlock.protoType);
                this.updateBlockLayer();
                this.renderLayer(this.blockLayerData, this.blockLayer);
            }
			this.createGame = () => {
				if (typeof this.currentGame !== 'undefined') this.currentGame.gameInfo.remove();
				this.currentGame = new this.Game(this.MS_TETRIS, this.gameOption);
			}
			this.startGame = () => {
				this.refresh();
				this.createGame();
                this.addTouchEventListener();
                this.addKeyEventListener();
                this.addPauseEventListener();
				this.setInterval(this.currentGame.speed);
				this.overlay.remove();
			}
            this.pauseGame = () => {
                if (typeof this.currentGame === 'undefined' || !this.currentGame.started) return;
                this.currentGame.paused = true;
                clearInterval(this.interval);
                this.removeTouchEventListener();
                this.removeKeyEventListener();
                this.setOverlay("pause");
            }
            this.resumeGame = () => {
                this.currentGame.paused = false;
                this.setInterval(this.currentGame.speed);
                this.addTouchEventListener();
                this.addKeyEventListener();
                this.overlay.remove();
            }
            this.endGame = () => {
                this.currentGame.started = false;
                this.removeTouchEventListener();
                this.removeKeyEventListener();
                this.setOverlay("gameover");
            }
            this.pickType = () => {
                const protoType = this.protoTypes[Math.floor(Math.random() * Object.keys(this.protoTypes).length + 1)];
                const blockWidth = protoType.types[0].length;
				const position = {x: 0, y: 0};
				position.x = Math.floor(this.grid.horizontal / 2) - (Math.floor(blockWidth / 2));
                protoType.types[0].forEach((row, y) => {
                    if (position.y < 0) return;
                    if (row.includes(1)) position.y -= y;
                });
                return {protoType, position};
            }
            this.initLayerData = () => {
                const layerData = [];
                for (let y = 0; y < this.grid.vertical; y++) {
                    const row = [];
                    for (let x = 0; x < this.grid.horizontal; x++) {
                        row.push(0);
                    }
                    layerData.push(row);
                }
                return layerData;
            };
            this.clearLayerData = (data) => {
                data.forEach((row, y) => {
                    row.forEach((col, x) => {
                        data[y][x] = 0;
                    });
                });
            }
			this.setRootLayer = () => {
				this.MS_TETRIS = document.createElement("div");
				this.MS_TETRIS.id = "MS_TETRIS";
				document.querySelector("body").appendChild(this.MS_TETRIS);
			}
            this.setFieldLayer = () => {
                this.fieldLayer = document.createElement("div");
                this.fieldLayer.id = "field-layer";
                this.fieldLayer.classList.add("layer");
                this.fieldLayer.setAttribute("style", 
                `
                    width: ${this.grid.horizontal * this.cellSize}rem;
                    height: ${this.grid.vertical * this.cellSize}rem;
                `);
                this.fieldLayerData = this.initLayerData();
                this.fieldLayerData.forEach((row, y) => {
                    row.forEach((col, x) => {
                        const cell = document.createElement("span");
                        cell.classList.add(`cell${y}-${x}`);
                        cell.setAttribute("style", 
                        `
                            width: ${this.cellSize}rem;
                            height: ${this.cellSize}rem;
                        `);
                        const colorLayer = document.createElement("i");
                        colorLayer.classList.add("colorLayer");
                        colorLayer.setAttribute("style", 
                        `
                            width: ${this.cellSize}rem;
                            height: ${this.cellSize}rem;
                        `);
                        cell.appendChild(colorLayer);
                        this.fieldLayer.appendChild(cell);
                    });
                });
                this.MS_TETRIS.appendChild(this.fieldLayer);
            }
            this.setBlockLayer = () => {
                this.blockLayerData = this.initLayerData();
                this.blockLayer = this.fieldLayer.cloneNode(true);
                this.blockLayer.id = "block-layer";
                this.MS_TETRIS.appendChild(this.blockLayer);
            }
            this.setNextBlockPreview = (protoType) => {
                if (typeof this.nextBlockPreview === 'undefined') {
                    this.nextBlockPreview = document.createElement("div");
                    this.nextBlockPreview.id = "next-block-preview";
                    this.nextBlockPreview.classList.add("layer");
                    this.nextBlockPreview.setAttribute("style", 
                    `
                        width: ${protoType.types[0][0].length * this.cellSize}rem;
                        height: ${protoType.types[0].length * this.cellSize}rem;
                        position: absolute;
                        left: 100%;
                        top: 0;
                        overflow: hidden;
                    `);
                }
                this.nextBlockPreview.innerHTML = "";
                protoType.types[0].forEach((row, y) => {
                    row.forEach((col, x) => {
                        const cell = document.createElement("span");
                        cell.classList.add(`cell${y}-${x}`);
                        cell.setAttribute("style", 
                        `
                            width: ${this.cellSize}rem;
                            height: ${this.cellSize}rem;
                        `);
                        const colorLayer = document.createElement("i");
                        colorLayer.classList.add("colorLayer");
                        colorLayer.setAttribute("style", 
                        `
                            width: ${this.cellSize}rem;
                            height: ${this.cellSize}rem;
                        `);
                        cell.appendChild(colorLayer);
                        if (col) {
                            cell.classList.add("valid");
                            colorLayer.style.background = protoType.color;
                        }
                        this.nextBlockPreview.appendChild(cell);
                    });
                });
                this.MS_TETRIS.appendChild(this.nextBlockPreview);
            }
			this.setOverlay = (type) => {
                if (typeof this.overlay === 'undefined') {
                    this.overlay = document.createElement("div");
                    this.overlay.id = "overlay";
                    this.innerOverlay = document.createElement("div");
                    this.innerOverlay.classList.add("inner");
                    this.overlay.appendChild(this.innerOverlay);
                    this.startButton = document.createElement("button");
                    this.startButton.id = "start";
                    this.restartButton = document.createElement("button");
                    this.restartButton.id = "restart";
                }
                this.innerOverlay.innerHTML = "";
                if (typeof type === 'undefined') {
                    this.startButton.textContent = "GAME START";
                } else if (type === 'pause') {
                    this.startButton.textContent = "RESUME GAME";
                    this.restartButton.textContent = "NEW GAME";
                    this.innerOverlay.append(this.restartButton);
                } else if (type === 'gameover') {
                    this.innerOverlay.innerHTML =
                    `
                        <h3 class="title">GAME OVER</h3>
                        <div class="gameInfo stage">
                            <em>STAGE: </em>
                            <span class="value">${this.currentGame.stage}</span>
                        </div>
                        <div class="gameInfo score">
                            <em>SCORE: </em>
                            <span class="value">${this.currentGame.score}</span>
                        </div>
					`;
                    this.startButton.textContent = "START NEW GAME";
                }
                this.innerOverlay.appendChild(this.startButton);
                
                this.MS_TETRIS.appendChild(this.overlay);
			}
            this.move = (direction) => {
                const targetPosition = {...this.currentBlock.position}
                const moveAmount = typeof amount === 'undefined' ? 1 : amount;
                switch (direction) {
                    case "down": targetPosition.y ++; break;
                    case "left": targetPosition.x --; break;
                    case "right": targetPosition.x ++; break;
					case "bottom": 
						while(!this.checkCollision(this.currentBlock.currentType, targetPosition)) {
							targetPosition.y ++;
						}
						this.currentBlock.position.y = targetPosition.y - 1;
						this.updateBlockLayer();
						break;
                }
                if (this.checkCollision(this.currentBlock.currentType, targetPosition)) {
                    if (direction === "down" || direction === "bottom") {
                        clearInterval(this.interval);
                        this.mergeLayer();
                        this.createBlock();
                        if (this.checkCollision(this.currentBlock.currentType, this.currentBlock.position)) {
                            this.endGame();
                            return;
                        }
						this.currentGame.clearBlock();
                        this.setInterval(this.currentGame.speed);
                    } else {
                        return;
                    }
                } else {
                    this.currentBlock.position = targetPosition;
                    this.updateBlockLayer();
                    this.renderLayer(this.blockLayerData, this.blockLayer);
                };
            }
            this.setInterval = (speed) => {
                this.interval = setInterval(() => {
                    this.move("down");
                }, speed);
            }
            this.updateBlockLayer = () => {
                this.clearLayerData(this.blockLayerData);
                this.currentBlock.protoType.types[this.currentBlock.currentType].forEach((row, y) => {
                    const targetY = this.currentBlock.position.y + y;
                    if (typeof this.blockLayerData[targetY] === 'undefined') return;
                    row.forEach((col, x) => {
                        const targetX = this.currentBlock.position.x + x;
                        if (typeof this.blockLayerData[targetY][targetX] === 'undefined') return;
                        this.blockLayerData[targetY][targetX] = col ? this.currentBlock.protoType.color : col;
                    });
                });
            }
            this.mergeLayer = () => {
                const currentBlockType = this.currentBlock.protoType.types[this.currentBlock.currentType]; 
                let clearedLines = 0;
                for (let y = this.currentBlock.position.y; y < this.currentBlock.position.y + currentBlockType.length; y ++) {
                    for (let x = this.currentBlock.position.x; x < this.currentBlock.position.x + currentBlockType[0].length; x ++) {
                        if (typeof this.blockLayerData[y] === 'undefined'
                            || typeof this.blockLayerData[y][x] === 'undefined'
                            || !this.blockLayerData[y][x]) {
                            continue;
                        }
                        this.fieldLayerData[y][x] = this.blockLayerData[y][x];
                        if (!this.fieldLayerData[y].includes(0)) {
                            this.fieldLayerData.splice(y, 1);
                            this.fieldLayerData.unshift(Array.from({length: this.grid.horizontal}, () => 0));
                            clearedLines ++;
                        }
                    }
                }
                if (clearedLines) this.currentGame.clearLine(clearedLines);
                this.clearLayerData(this.blockLayerData);
                this.renderLayer(this.fieldLayerData, this.fieldLayer);
                this.renderLayer(this.blockLayerData, this.blockLayer);

                this.removeTouchEventListener();
                this.addTouchEventListener();
            }
            this.checkCollision = (type, position) => {
                let collision = false;
                this.currentBlock.protoType.types[type].forEach((row, y) => {
                    row.forEach((col, x) => {
                        const fieldY = position.y + y;
                        const fieldX = position.x + x;
                        if (typeof this.fieldLayerData[fieldY] === 'undefined') {
                            if (col) collision = true;
                        } else {
                            if (col) {
                                if (typeof this.fieldLayerData[fieldY][fieldX] === 'undefined') {
                                    collision = true;
                                }
                                if (this.fieldLayerData[fieldY][fieldX]) {
                                    collision = true;
                                }
                            }
                        }
                    });
                });
                return collision;
            }
            this.renderLayer = (data, target) => {
                data.forEach((row, y) => {
                    row.forEach((col, x) => {
                        const cell = target.querySelector(`.cell${y}-${x}`);
                        const colorLayer = cell.querySelector(".colorLayer");
                        col ? cell.classList.add("valid") : cell.classList.remove("valid");
                        colorLayer.style.background = col ? col : "transparent";
                    });
                });
            }
			this.compareEdge = (nextType) => {
				const currentBlockType = this.currentBlock.protoType.types;
				let currentTop = currentBlockType[this.currentBlock.currentType].length - 1;
				let currentLeft = currentBlockType[this.currentBlock.currentType][0].length - 1;
				let currentRight = 0;
				currentBlockType[this.currentBlock.currentType].forEach((row, y) => {
					row.forEach((col, x) => {
						if (col) {
							if (y < currentTop) currentTop = y;
							if (x < currentLeft) currentLeft = x;
							if (x > currentRight) currentRight = x;
						}
					});
				});
				let nextTop = currentBlockType[nextType].length - 1;
				let nextLeft = currentBlockType[nextType][0].length - 1;
				let nextRight = 0;
				currentBlockType[nextType].forEach((row, y) => {
					row.forEach((col, x) => {
						if (col) {
							if (y < nextTop) nextTop = y;
							if (x < nextLeft) nextLeft = x;
							if (x > nextRight) nextRight = x;
						}
					});
				});
				return {top: currentTop - nextTop, left: currentLeft - nextLeft, right: currentRight - nextRight}
			}
            this.changeType = ()  => {
                const nextType = typeof this.currentBlock.protoType.types[this.currentBlock.currentType + 1] === 'undefined' ? 0 : this.currentBlock.currentType + 1;
				const targetPosition = {...this.currentBlock.position};
                if (this.checkCollision(nextType, targetPosition)) {
					const comparedEdge = this.compareEdge(nextType);
					if (this.currentBlock.position.y < this.currentBlock.protoType.types[this.currentBlock.currentType].length) {
						targetPosition.y = targetPosition.y + comparedEdge.top;
					}
					if (this.currentBlock.position.x < this.currentBlock.protoType.types[this.currentBlock.currentType][0].length) {
						targetPosition.x = targetPosition.x + comparedEdge.left;						
					}
					if (this.currentBlock.position.x + this.currentBlock.protoType.types[this.currentBlock.currentType][0].length > this.grid.horizontal) {
						targetPosition.x = targetPosition.x + comparedEdge.right;
					}	
				}
				if (!this.checkCollision(nextType, targetPosition)) {
					this.currentBlock.position = targetPosition;
					this.currentBlock.currentType = nextType;
					this.updateBlockLayer();
					this.renderLayer(this.blockLayerData, this.blockLayer);
				}
            }
			this.refresh = () => {
				clearInterval(this.interval);
				this.renderLayer(this.blockLayerData, this.blockLayer);
				this.clearLayerData(this.fieldLayerData);
				this.renderLayer(this.fieldLayerData, this.fieldLayer);
				this.createBlock();
			}
            this.initTouchStatus = (e) => {
                this.touchStatus["initialX"] = e.clientX;
                this.touchStatus["initialY"] = e.clientY;
            }
            this.addTouchEventListener = () => {
                this.touchStatus = {};
                this.touchStatus["dragging"] = false;
                this.touchStatus["unit"] = this.blockLayer.querySelectorAll('[class*=cell]')[0].offsetWidth;

                this.handlePointerDown = (e) => {
                    this.touchStatus.dragging = true;
                    this.initTouchStatus(e);
                    e.target.setPointerCapture(e.pointerId);
                    this.touchStatus["initialTime"] = Date.now();
                    this.touchStatus["moveTime"] = this.touchStatus.initialTime;
                    this.touchStatus["consecutiveX"] = 0;
                    this.touchStatus["consecutiveY"] = 0;
                    this.touchStatus["beforeAbsX"] = 0;
                    this.touchStatus["beforeAbsY"] = 0;
                    this.touchStatus["accelerationX"] = 0;
                    this.touchStatus["accelerationY"] = 0;

                    this.MS_TETRIS.addEventListener('pointermove', this.handlePointerMove);
                    this.MS_TETRIS.addEventListener('pointerup', this.handlePointerUp);
                }
                this.handlePointerMove = (e) => {                    
                    if (!this.touchStatus.dragging) return;
                    const movedDuration = Date.now() - this.touchStatus.moveTime;
                    if (movedDuration < 15) return;
                    this.touchStatus["movedAmountX"] = e.clientX - this.touchStatus.initialX;
                    this.touchStatus["movedAmountY"] = e.clientY - this.touchStatus.initialY;
                    this.touchStatus["absMovedAmountX"] = Math.abs(this.touchStatus.movedAmountX);
                    this.touchStatus["absMovedAmountY"] = Math.abs(this.touchStatus.movedAmountY);
                    
                    if (this.touchStatus.absMovedAmountX > this.touchStatus.absMovedAmountY) {
                        if (this.touchStatus.absMovedAmountX < 5) return;
                        this.touchStatus["direction"] = "h";
                        if (this.touchStatus.direction === "h") {
                            this.touchStatus.consecutiveX ++;
                            this.touchStatus.consecutiveY = 0;
                            if (this.touchStatus.beforeAbsX < this.touchStatus.movedAmountX) this.touchStatus.accelerationX ++;
                            else this.touchStatus.accelerationX = 0;
                        }
                    } else if (this.touchStatus.absMovedAmountY > this.touchStatus.absMovedAmountX) {
                        if (this.touchStatus.absMovedAmountY < 10) return;
                        this.touchStatus["direction"] = "v";
                        if (this.touchStatus.direction === "v") {
                            this.touchStatus.consecutiveX = 0;
                            this.touchStatus.consecutiveY ++;
                            if (this.touchStatus.beforeAbsY < this.touchStatus.movedAmountY) this.touchStatus.accelerationY ++;
                            else this.touchStatus.accelerationY = 0;
                            if (this.touchStatus.accelerationY > 10) {
                                return;
                            }
                        }
                    }
                    if (this.touchStatus.direction === "v") {
                        const currentAmount = this.touchStatus.absMovedAmountY / this.touchStatus.unit;
                        if (movedDuration < 30) return;
                        if (this.touchStatus.consecutiveY > 2 && this.touchStatus.accelerationY > 2 && this.touchStatus.movedAmountY > this.touchStatus.unit) {
                            this.touchStatus["allowBottom"] = true;
                            return;
                        }
                        this.move("down");
                        this.touchStatus.moved = true;
                        this.initTouchStatus(e);
                    }
                    if (this.touchStatus.direction === "h") {
                        if (movedDuration < 30 || this.touchStatus.absMovedAmountX < 10) return;
                        if (this.touchStatus.consecutiveY > 3 && this.touchStatus.accelerationY > 8) return;
                        this.touchStatus.movedAmountX < 0 ? this.move("left") : this.move("right");
                        this.touchStatus.moved = true;
                        this.initTouchStatus(e);
                    }
                    this.touchStatus["moveTime"] = Date.now();
                    this.touchStatus.beforeAbsX = this.touchStatus.absMovedAmountX;
                    this.touchStatus.beforeAbsY = this.touchStatus.absMovedAmountY;
                }
                this.handlePointerUp = (e) => {
                    this.touchStatus.dragging = false;
                    e.target.releasePointerCapture(e.pointerId);
                    const moved = typeof this.touchStatus.moved !== 'undefined' && this.touchStatus.moved ? true : false;
                        if (typeof this.touchStatus.allowBottom !== 'undefined' && this.touchStatus.allowBottom) {
                            this.move("down");
                            this.move("bottom");
                        } else {
                            if (!moved && !this.touchStatus.allowBottom && (this.touchStatus.movedAmountX < this.touchStatus.unit && this.touchStatus.movedAmountY < this.touchStatus.unit)) this.changeType();
                        }
                    
                    this.touchStatus["moved"] = false;
                    this.initTouchStatus(e);
                    this.touchStatus.movedAmountX = 0;
                    this.touchStatus.movedAmountY = 0;
                    this.touchStatus.absMovedAmountX = 0;
                    this.touchStatus.absMovedAmountY = 0;
                    this.touchStatus.consecutiveX = 0;
                    this.touchStatus.consecutiveY = 0;

                    this.MS_TETRIS.removeEventListener('pointermove', this.handlePointerMove);
                    this.MS_TETRIS.removeEventListener('pointerup', this.handlePointerUp);
                }
                
                this.MS_TETRIS.addEventListener('pointerdown', this.handlePointerDown);
            }
            this.removeTouchEventListener = () => {
                this.MS_TETRIS.removeEventListener('pointerdown', this.handlePointerDown);
                this.MS_TETRIS.removeEventListener('pointermove', this.handlePointerMove);
                this.MS_TETRIS.removeEventListener('pointerup', this.handlePointerUp);
            }
            this.addPauseEventListener = () => {
                this.currentGame.pauseButton.addEventListener("click", e => {
                    this.pauseGame();
                });
            }
            this.handleKeyDown = (e) => {
                switch (e.keyCode) {
                    case 40: this.move("down"); break;
                    case 37: this.move("left"); break;
                    case 39: this.move("right"); break;
                    case 38: this.changeType(); break;
				    case 32: this.move("bottom"); break;
                }
            }
            this.addKeyEventListener = () => {
                document.addEventListener("keydown", this.handleKeyDown);
            }
            this.removeKeyEventListener = () => {
                document.removeEventListener("keydown", this.handleKeyDown);
            }
            this.addEventListener = () => {
				this.startButton.addEventListener("click", e => {
                    if (typeof this.currentGame === 'undefined') {
                        this.startGame();
                    } else if (this.currentGame.paused) {
                        this.resumeGame();
                    } else {
                        this.startGame();
                    }
				});
                this.restartButton.addEventListener("click", e => {
                    this.startGame();
				});
                document.addEventListener("keydown", e => {
                    if (e.keyCode === 32) {
                        if (typeof this.currentGame === 'undefined') {
                            this.startGame();
                        } else if (this.currentGame.paused) {
                            this.startGame();
                        } else if (!this.currentGame.started) {
                            this.startGame();
                        }
                    } else if (e.keyCode === 27) {
                        if (typeof this.currentGame === 'undefined') return;
                        if (this.currentGame.started && !this.currentGame.paused) {
                            this.pauseGame();
                        } else if (this.currentGame.paused) {
                            this.resumeGame();
                        }
                        
                    }
                    
				});
                document.addEventListener("visibilitychange", () => {
                    if (document.hidden) this.pauseGame();
                });
                document.addEventListener("blur", () => {
                    this.pauseGame();
                });
            }
            this.init = () => {
				this.setRootLayer();
                this.setFieldLayer();
                this.setBlockLayer();
				this.setOverlay();
                this.addEventListener();
            }
            return this;
        }

        const ms_tetris = new MS_TETRIS();
        ms_tetris.init();
    </script>
</body>
</html>




